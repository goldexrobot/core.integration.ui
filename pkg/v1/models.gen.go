// Package api provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen version v1.11.1-0.20220912230023-4a1477f6a8ba DO NOT EDIT.
package api

import (
	"encoding/json"
	"errors"

	"github.com/deepmap/oapi-codegen/pkg/runtime"
)

// Defines values for EvalHydroResultFailureFailure.
const (
	EvalHydroResultFailureFailureItemRejected       EvalHydroResultFailureFailure = "item_rejected"
	EvalHydroResultFailureFailureNetworkUnavailable EvalHydroResultFailureFailure = "network_unavailable"
	EvalHydroResultFailureFailureUnstableScale      EvalHydroResultFailureFailure = "unstable_scale"
)

// Defines values for EvalNewResultFailureFailure.
const (
	EvalNewResultFailureFailureHardwareCheckFailed EvalNewResultFailureFailure = "hardware_check_failed"
	EvalNewResultFailureFailureNetworkUnavailable  EvalNewResultFailureFailure = "network_unavailable"
	EvalNewResultFailureFailureNoStorageRoom       EvalNewResultFailureFailure = "no_storage_room"
)

// Defines values for EvalSpectrumResultFailureFailure.
const (
	EvalSpectrumResultFailureFailureItemRejected       EvalSpectrumResultFailureFailure = "item_rejected"
	EvalSpectrumResultFailureFailureNetworkUnavailable EvalSpectrumResultFailureFailure = "network_unavailable"
)

// Defines values for EvalStoreRequestDomain.
const (
	EvalStoreRequestDomainBuyout   EvalStoreRequestDomain = "buyout"
	EvalStoreRequestDomainCustom   EvalStoreRequestDomain = "custom"
	EvalStoreRequestDomainPawnshop EvalStoreRequestDomain = "pawnshop"
)

// Defines values for EvalStoreResultFailureFailure.
const (
	EvalStoreResultFailureFailureForbidden          EvalStoreResultFailureFailure = "forbidden"
	EvalStoreResultFailureFailureNetworkUnavailable EvalStoreResultFailureFailure = "network_unavailable"
)

// Defines values for ItemRejectionReason.
const (
	HighWeight  ItemRejectionReason = "high_weight"
	LowSpectrum ItemRejectionReason = "low_spectrum"
	LowWeight   ItemRejectionReason = "low_weight"
	Unconfirmed ItemRejectionReason = "unconfirmed"
	Undescribed ItemRejectionReason = "undescribed"
)

// Defines values for StorageExtractRequestDomain.
const (
	StorageExtractRequestDomainCustom   StorageExtractRequestDomain = "custom"
	StorageExtractRequestDomainPawnshop StorageExtractRequestDomain = "pawnshop"
	StorageExtractRequestDomainShop     StorageExtractRequestDomain = "shop"
)

// Defines values for StorageExtractResultFailureFailure.
const (
	Forbidden          StorageExtractResultFailureFailure = "forbidden"
	NetworkUnavailable StorageExtractResultFailureFailure = "network_unavailable"
)

// Defines values for SuccessFlag.
const (
	False SuccessFlag = "false"
	True  SuccessFlag = "true"
)

// EvalHydroResult defines model for EvalHydroResult.
type EvalHydroResult struct {
	union json.RawMessage
}

// EvalHydroResultFailure defines model for EvalHydroResultFailure.
type EvalHydroResultFailure struct {
	Failure EvalHydroResultFailureFailure `json:"failure"`

	// Reason Reason why the item is rejected by the Goldex. It's non-empty if evaluation failure is `item_rejected`
	Reason ItemRejectionReason `json:"reason"`

	// Success Success flag, string representation
	Success SuccessFlag `json:"success"`
}

// EvalHydroResultFailureFailure defines model for EvalHydroResultFailure.Failure.
type EvalHydroResultFailureFailure string

// EvalHydroResultSuccess defines model for EvalHydroResultSuccess.
type EvalHydroResultSuccess struct {
	// Alloy Valuable metal
	Alloy string `json:"alloy"`

	// Carat Fineness in carats
	Carat string `json:"carat"`

	// Confidence Evaluation confidence, 1.0 - is confident, 0.0 - is not, 0.8 - is "pretty" confident
	Confidence float64 `json:"confidence"`

	// Millesimal Millesimal fineness, 585 stands for 58.5%, 999 for 99.9%, 9999 for 99.99%
	Millesimal int64 `json:"millesimal"`

	// Purity Content of the valuable metal in percents
	Purity float64 `json:"purity"`

	// Risky Automatic decision result
	Risky bool `json:"risky"`

	// Success Success flag, string representation
	Success SuccessFlag `json:"success"`

	// Warnings Warnings that should help with decision. For instance, there could be a tungsten covered with gold.
	Warnings []string `json:"warnings"`

	// Weight Weight in grams
	Weight float64 `json:"weight"`
}

// EvalNewResult Data depending on success flag
type EvalNewResult struct {
	union json.RawMessage
}

// EvalNewResultFailure defines model for EvalNewResultFailure.
type EvalNewResultFailure struct {
	Failure EvalNewResultFailureFailure `json:"failure"`

	// Success Success flag, string representation
	Success SuccessFlag `json:"success"`
}

// EvalNewResultFailureFailure defines model for EvalNewResultFailure.Failure.
type EvalNewResultFailureFailure string

// EvalNewResultSuccess defines model for EvalNewResultSuccess.
type EvalNewResultSuccess struct {
	// EvalId Evaluation ID
	EvalId uint64 `json:"eval_id"`

	// StorageCell Storage cell address
	StorageCell StorageCell `json:"storage_cell" validate:"required,alphanum,min=2,max=4"`

	// Success Success flag, string representation
	Success SuccessFlag `json:"success"`
}

// EvalSpectrumResult defines model for EvalSpectrumResult.
type EvalSpectrumResult struct {
	union json.RawMessage
}

// EvalSpectrumResultFailure defines model for EvalSpectrumResultFailure.
type EvalSpectrumResultFailure struct {
	Failure EvalSpectrumResultFailureFailure `json:"failure"`

	// Reason Reason why the item is rejected by the Goldex. It's non-empty if evaluation failure is `item_rejected`
	Reason ItemRejectionReason `json:"reason"`

	// Success Success flag, string representation
	Success SuccessFlag `json:"success"`
}

// EvalSpectrumResultFailureFailure defines model for EvalSpectrumResultFailure.Failure.
type EvalSpectrumResultFailureFailure string

// EvalSpectrumResultSuccess defines model for EvalSpectrumResultSuccess.
type EvalSpectrumResultSuccess struct {
	// Alloy Valuable metal
	Alloy string `json:"alloy"`

	// Carat Fineness in carats
	Carat string `json:"carat"`

	// Millesimal Millesimal fineness. 585 stands for 58.5%, 999 for 99.9%, 9999 for 99.99%
	Millesimal int64 `json:"millesimal"`

	// Purity Content of the valuable metal in percents
	Purity float64 `json:"purity"`

	// Spectrum Spectrum data
	Spectrum map[string]float64 `json:"spectrum"`

	// Success Success flag, string representation
	Success SuccessFlag `json:"success"`
}

// EvalStoreRequest defines model for EvalStoreRequest.
type EvalStoreRequest struct {
	// Domain Cell occupation operation domain
	Domain EvalStoreRequestDomain `json:"domain" validate:"required,oneof=buyout pawnshop custom"`
}

// EvalStoreRequestDomain Cell occupation operation domain
type EvalStoreRequestDomain string

// EvalStoreResult defines model for EvalStoreResult.
type EvalStoreResult struct {
	union json.RawMessage
}

// EvalStoreResultFailure defines model for EvalStoreResultFailure.
type EvalStoreResultFailure struct {
	Failure EvalStoreResultFailureFailure `json:"failure"`

	// Success Success flag, string representation
	Success SuccessFlag `json:"success"`
}

// EvalStoreResultFailureFailure defines model for EvalStoreResultFailure.Failure.
type EvalStoreResultFailureFailure string

// EvalStoreResultSuccess defines model for EvalStoreResultSuccess.
type EvalStoreResultSuccess struct {
	// Cell Storage cell address
	Cell StorageCell `json:"cell" validate:"required,alphanum,min=2,max=4"`

	// Success Success flag, string representation
	Success SuccessFlag `json:"success"`

	// Transaction Unique storage cell operation ID
	Transaction StorageCellTransaction `json:"transaction"`
}

// HardwareEvent defines model for HardwareEvent.
type HardwareEvent struct {
	// Data Event data
	Data map[string]interface{} `json:"data"`

	// Event Event name
	Event string `json:"event"`

	// Name Named hardware
	Name string `json:"name"`
}

// HardwareRequest defines model for HardwareRequest.
type HardwareRequest struct {
	// Method Method name
	Method string `json:"method" validate:"required"`

	// Name Named hardware
	Name string `json:"name" validate:"required"`

	// Params Method params
	Params json.RawMessage `json:"params"`
}

// HardwareResult defines model for HardwareResult.
type HardwareResult struct {
	// Result Hardware method result
	Result json.RawMessage `json:"result"`
}

// InletCloseResult defines model for InletCloseResult.
type InletCloseResult struct {
	// Success Success flag, string representation
	Success SuccessFlag `json:"success"`
}

// ItemRejectionReason Reason why the item is rejected by the Goldex. It's non-empty if evaluation failure is `item_rejected`
type ItemRejectionReason string

// OutletCloseResult defines model for OutletCloseResult.
type OutletCloseResult struct {
	// Success Success flag, string representation
	Success SuccessFlag `json:"success"`
}

// ProxyRequest defines model for ProxyRequest.
type ProxyRequest struct {
	// Body Request key-value
	Body map[string]interface{} `json:"body"`

	// Endpoint Predefined endpoint name
	Endpoint string `json:"endpoint" validate:"required"`
}

// ProxyResult defines model for ProxyResult.
type ProxyResult struct {
	// Body Result key-value
	Body map[string]interface{} `json:"body"`

	// HttpStatus http status
	HttpStatus int64 `json:"http_status"`
}

// StatusResult defines model for StatusResult.
type StatusResult struct {
	BotId    uint64               `json:"bot_id"`
	Features StatusResultFeatures `json:"features"`

	// InternetConnection Internet connectivity
	InternetConnection bool `json:"internet_connection"`

	// Operational Operational status. False if robot is broken or some mandatory hardware is unavailable
	Operational bool `json:"operational"`

	// OptionalHardware available optional hardware
	OptionalHardware map[string]bool `json:"optional_hardware"`
	ProjectId        uint64          `json:"project_id"`
}

// StatusResultFeatures defines model for StatusResultFeatures.
type StatusResultFeatures struct {
	// PositionalStorage Items storage is a positional storage (has cells to store items)
	PositionalStorage bool `json:"positional_storage"`

	// Storage Items storage is available
	Storage bool `json:"storage"`
}

// StorageCell Storage cell address
type StorageCell = string

// StorageCellTransaction Unique storage cell operation ID
type StorageCellTransaction = string

// StorageExtractRequest defines model for StorageExtractRequest.
type StorageExtractRequest struct {
	// Cell Storage cell address
	Cell StorageCell `json:"cell" validate:"required,alphanum,min=2,max=4"`

	// Domain Cell release operation domain
	Domain StorageExtractRequestDomain `json:"domain" validate:"required,oneof=shop pawnshop custom"`
}

// StorageExtractRequestDomain Cell release operation domain
type StorageExtractRequestDomain string

// StorageExtractResult defines model for StorageExtractResult.
type StorageExtractResult struct {
	union json.RawMessage
}

// StorageExtractResultFailure defines model for StorageExtractResultFailure.
type StorageExtractResultFailure struct {
	Failure StorageExtractResultFailureFailure `json:"failure"`

	// Success Success flag, string representation
	Success SuccessFlag `json:"success"`
}

// StorageExtractResultFailureFailure defines model for StorageExtractResultFailure.Failure.
type StorageExtractResultFailureFailure string

// StorageExtractResultSuccess defines model for StorageExtractResultSuccess.
type StorageExtractResultSuccess struct {
	// Success Success flag, string representation
	Success SuccessFlag `json:"success"`

	// Transaction Unique storage cell operation ID
	Transaction StorageCellTransaction `json:"transaction"`
}

// SuccessFlag Success flag, string representation
type SuccessFlag string

// EmptyResult defines model for EmptyResult.
type EmptyResult = map[string]interface{}

// Error defines model for Error.
type Error struct {
	// Code Standard or implementation-dependent error code
	Code float32 `json:"code"`

	// Message Error description
	Message string `json:"message"`
}

// EmptyParams defines model for EmptyParams.
type EmptyParams = map[string]interface{}

// EvalHydroJSONBody defines parameters for EvalHydro.
type EvalHydroJSONBody = map[string]interface{}

// EvalNewJSONBody defines parameters for EvalNew.
type EvalNewJSONBody = map[string]interface{}

// EvalReturnJSONBody defines parameters for EvalReturn.
type EvalReturnJSONBody = map[string]interface{}

// EvalSpectrumJSONBody defines parameters for EvalSpectrum.
type EvalSpectrumJSONBody = map[string]interface{}

// InletCloseJSONBody defines parameters for InletClose.
type InletCloseJSONBody = map[string]interface{}

// InletOpenJSONBody defines parameters for InletOpen.
type InletOpenJSONBody = map[string]interface{}

// OutletCloseJSONBody defines parameters for OutletClose.
type OutletCloseJSONBody = map[string]interface{}

// StatusJSONBody defines parameters for Status.
type StatusJSONBody = map[string]interface{}

// EvalHydroJSONRequestBody defines body for EvalHydro for application/json ContentType.
type EvalHydroJSONRequestBody = EvalHydroJSONBody

// EvalNewJSONRequestBody defines body for EvalNew for application/json ContentType.
type EvalNewJSONRequestBody = EvalNewJSONBody

// EvalReturnJSONRequestBody defines body for EvalReturn for application/json ContentType.
type EvalReturnJSONRequestBody = EvalReturnJSONBody

// EvalSpectrumJSONRequestBody defines body for EvalSpectrum for application/json ContentType.
type EvalSpectrumJSONRequestBody = EvalSpectrumJSONBody

// EvalStoreJSONRequestBody defines body for EvalStore for application/json ContentType.
type EvalStoreJSONRequestBody = EvalStoreRequest

// HardwareEventJSONRequestBody defines body for HardwareEvent for application/json ContentType.
type HardwareEventJSONRequestBody = HardwareEvent

// HardwareJSONRequestBody defines body for Hardware for application/json ContentType.
type HardwareJSONRequestBody = HardwareRequest

// InletCloseJSONRequestBody defines body for InletClose for application/json ContentType.
type InletCloseJSONRequestBody = InletCloseJSONBody

// InletOpenJSONRequestBody defines body for InletOpen for application/json ContentType.
type InletOpenJSONRequestBody = InletOpenJSONBody

// OutletCloseJSONRequestBody defines body for OutletClose for application/json ContentType.
type OutletCloseJSONRequestBody = OutletCloseJSONBody

// ProxyJSONRequestBody defines body for Proxy for application/json ContentType.
type ProxyJSONRequestBody = ProxyRequest

// StatusJSONRequestBody defines body for Status for application/json ContentType.
type StatusJSONRequestBody = StatusJSONBody

// StorageExtractJSONRequestBody defines body for StorageExtract for application/json ContentType.
type StorageExtractJSONRequestBody = StorageExtractRequest

// AsEvalHydroResultSuccess returns the union data inside the EvalHydroResult as a EvalHydroResultSuccess
func (t EvalHydroResult) AsEvalHydroResultSuccess() (EvalHydroResultSuccess, error) {
	var body EvalHydroResultSuccess
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromEvalHydroResultSuccess overwrites any union data inside the EvalHydroResult as the provided EvalHydroResultSuccess
func (t *EvalHydroResult) FromEvalHydroResultSuccess(v EvalHydroResultSuccess) error {
	v.Success = "true"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeEvalHydroResultSuccess performs a merge with any union data inside the EvalHydroResult, using the provided EvalHydroResultSuccess
func (t *EvalHydroResult) MergeEvalHydroResultSuccess(v EvalHydroResultSuccess) error {
	v.Success = "true"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

// AsEvalHydroResultFailure returns the union data inside the EvalHydroResult as a EvalHydroResultFailure
func (t EvalHydroResult) AsEvalHydroResultFailure() (EvalHydroResultFailure, error) {
	var body EvalHydroResultFailure
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromEvalHydroResultFailure overwrites any union data inside the EvalHydroResult as the provided EvalHydroResultFailure
func (t *EvalHydroResult) FromEvalHydroResultFailure(v EvalHydroResultFailure) error {
	v.Success = "false"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeEvalHydroResultFailure performs a merge with any union data inside the EvalHydroResult, using the provided EvalHydroResultFailure
func (t *EvalHydroResult) MergeEvalHydroResultFailure(v EvalHydroResultFailure) error {
	v.Success = "false"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

func (t EvalHydroResult) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"success"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t EvalHydroResult) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "false":
		return t.AsEvalHydroResultFailure()
	case "true":
		return t.AsEvalHydroResultSuccess()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t EvalHydroResult) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *EvalHydroResult) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsEvalNewResultSuccess returns the union data inside the EvalNewResult as a EvalNewResultSuccess
func (t EvalNewResult) AsEvalNewResultSuccess() (EvalNewResultSuccess, error) {
	var body EvalNewResultSuccess
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromEvalNewResultSuccess overwrites any union data inside the EvalNewResult as the provided EvalNewResultSuccess
func (t *EvalNewResult) FromEvalNewResultSuccess(v EvalNewResultSuccess) error {
	v.Success = "true"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeEvalNewResultSuccess performs a merge with any union data inside the EvalNewResult, using the provided EvalNewResultSuccess
func (t *EvalNewResult) MergeEvalNewResultSuccess(v EvalNewResultSuccess) error {
	v.Success = "true"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

// AsEvalNewResultFailure returns the union data inside the EvalNewResult as a EvalNewResultFailure
func (t EvalNewResult) AsEvalNewResultFailure() (EvalNewResultFailure, error) {
	var body EvalNewResultFailure
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromEvalNewResultFailure overwrites any union data inside the EvalNewResult as the provided EvalNewResultFailure
func (t *EvalNewResult) FromEvalNewResultFailure(v EvalNewResultFailure) error {
	v.Success = "false"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeEvalNewResultFailure performs a merge with any union data inside the EvalNewResult, using the provided EvalNewResultFailure
func (t *EvalNewResult) MergeEvalNewResultFailure(v EvalNewResultFailure) error {
	v.Success = "false"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

func (t EvalNewResult) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"success"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t EvalNewResult) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "false":
		return t.AsEvalNewResultFailure()
	case "true":
		return t.AsEvalNewResultSuccess()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t EvalNewResult) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *EvalNewResult) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsEvalSpectrumResultSuccess returns the union data inside the EvalSpectrumResult as a EvalSpectrumResultSuccess
func (t EvalSpectrumResult) AsEvalSpectrumResultSuccess() (EvalSpectrumResultSuccess, error) {
	var body EvalSpectrumResultSuccess
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromEvalSpectrumResultSuccess overwrites any union data inside the EvalSpectrumResult as the provided EvalSpectrumResultSuccess
func (t *EvalSpectrumResult) FromEvalSpectrumResultSuccess(v EvalSpectrumResultSuccess) error {
	v.Success = "true"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeEvalSpectrumResultSuccess performs a merge with any union data inside the EvalSpectrumResult, using the provided EvalSpectrumResultSuccess
func (t *EvalSpectrumResult) MergeEvalSpectrumResultSuccess(v EvalSpectrumResultSuccess) error {
	v.Success = "true"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

// AsEvalSpectrumResultFailure returns the union data inside the EvalSpectrumResult as a EvalSpectrumResultFailure
func (t EvalSpectrumResult) AsEvalSpectrumResultFailure() (EvalSpectrumResultFailure, error) {
	var body EvalSpectrumResultFailure
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromEvalSpectrumResultFailure overwrites any union data inside the EvalSpectrumResult as the provided EvalSpectrumResultFailure
func (t *EvalSpectrumResult) FromEvalSpectrumResultFailure(v EvalSpectrumResultFailure) error {
	v.Success = "false"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeEvalSpectrumResultFailure performs a merge with any union data inside the EvalSpectrumResult, using the provided EvalSpectrumResultFailure
func (t *EvalSpectrumResult) MergeEvalSpectrumResultFailure(v EvalSpectrumResultFailure) error {
	v.Success = "false"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

func (t EvalSpectrumResult) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"success"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t EvalSpectrumResult) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "false":
		return t.AsEvalSpectrumResultFailure()
	case "true":
		return t.AsEvalSpectrumResultSuccess()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t EvalSpectrumResult) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *EvalSpectrumResult) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsEvalStoreResultSuccess returns the union data inside the EvalStoreResult as a EvalStoreResultSuccess
func (t EvalStoreResult) AsEvalStoreResultSuccess() (EvalStoreResultSuccess, error) {
	var body EvalStoreResultSuccess
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromEvalStoreResultSuccess overwrites any union data inside the EvalStoreResult as the provided EvalStoreResultSuccess
func (t *EvalStoreResult) FromEvalStoreResultSuccess(v EvalStoreResultSuccess) error {
	v.Success = "true"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeEvalStoreResultSuccess performs a merge with any union data inside the EvalStoreResult, using the provided EvalStoreResultSuccess
func (t *EvalStoreResult) MergeEvalStoreResultSuccess(v EvalStoreResultSuccess) error {
	v.Success = "true"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

// AsEvalStoreResultFailure returns the union data inside the EvalStoreResult as a EvalStoreResultFailure
func (t EvalStoreResult) AsEvalStoreResultFailure() (EvalStoreResultFailure, error) {
	var body EvalStoreResultFailure
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromEvalStoreResultFailure overwrites any union data inside the EvalStoreResult as the provided EvalStoreResultFailure
func (t *EvalStoreResult) FromEvalStoreResultFailure(v EvalStoreResultFailure) error {
	v.Success = "false"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeEvalStoreResultFailure performs a merge with any union data inside the EvalStoreResult, using the provided EvalStoreResultFailure
func (t *EvalStoreResult) MergeEvalStoreResultFailure(v EvalStoreResultFailure) error {
	v.Success = "false"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

func (t EvalStoreResult) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"success"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t EvalStoreResult) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "false":
		return t.AsEvalStoreResultFailure()
	case "true":
		return t.AsEvalStoreResultSuccess()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t EvalStoreResult) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *EvalStoreResult) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsStorageExtractResultSuccess returns the union data inside the StorageExtractResult as a StorageExtractResultSuccess
func (t StorageExtractResult) AsStorageExtractResultSuccess() (StorageExtractResultSuccess, error) {
	var body StorageExtractResultSuccess
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromStorageExtractResultSuccess overwrites any union data inside the StorageExtractResult as the provided StorageExtractResultSuccess
func (t *StorageExtractResult) FromStorageExtractResultSuccess(v StorageExtractResultSuccess) error {
	v.Success = "true"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeStorageExtractResultSuccess performs a merge with any union data inside the StorageExtractResult, using the provided StorageExtractResultSuccess
func (t *StorageExtractResult) MergeStorageExtractResultSuccess(v StorageExtractResultSuccess) error {
	v.Success = "true"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

// AsStorageExtractResultFailure returns the union data inside the StorageExtractResult as a StorageExtractResultFailure
func (t StorageExtractResult) AsStorageExtractResultFailure() (StorageExtractResultFailure, error) {
	var body StorageExtractResultFailure
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromStorageExtractResultFailure overwrites any union data inside the StorageExtractResult as the provided StorageExtractResultFailure
func (t *StorageExtractResult) FromStorageExtractResultFailure(v StorageExtractResultFailure) error {
	v.Success = "false"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeStorageExtractResultFailure performs a merge with any union data inside the StorageExtractResult, using the provided StorageExtractResultFailure
func (t *StorageExtractResult) MergeStorageExtractResultFailure(v StorageExtractResultFailure) error {
	v.Success = "false"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

func (t StorageExtractResult) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"success"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t StorageExtractResult) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "false":
		return t.AsStorageExtractResultFailure()
	case "true":
		return t.AsStorageExtractResultSuccess()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t StorageExtractResult) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *StorageExtractResult) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}
